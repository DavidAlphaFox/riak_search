/* -------------------------------------------------------------------
**
** riakclient.proto: Protocol buffers for riak
**
** Copyright (c) 2007-2010 Basho Technologies, Inc.  All Rights Reserved.
**
** This file is provided to you under the Apache License,
** Version 2.0 (the "License"); you may not use this file
** except in compliance with the License.  You may obtain
** a copy of the License at
**
**   http://www.apache.org/licenses/LICENSE-2.0
**
** Unless required by applicable law or agreed to in writing,
** software distributed under the License is distributed on an
** "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
** KIND, either express or implied.  See the License for the
** specific language governing permissions and limitations
** under the License.
**
** -------------------------------------------------------------------
*/
/*
** Lowest Common Denominator Protocol Buffers Client
**   - no ENUM (protobuffs_erlang does not support)
**
** <length:32>  <msg_code:8> <pbmsg>
**
** Messages
**  0 - RpbErrorResp
**  1 - RpbHelloReq
**  2 - RpbHelloResp
**  3 - RpbPingReq - 0 length
**  4 - RpbPingResp (pong) - 0 length
**  5 - RpbGetReq 
**  6 - RpbGetResp
**  7 - RpbPutReq 
**  8 - RpbPutResp - 0 length
**  9 - RpbDelReq 
** 10 - RpbDelResp
** 11 - RpbGetBucketPropsReq
** 12 - RpbGetBucketPropsResp
** 13 - RpbSetBucketPropsReq
** 14 - RpbSetBucketPropsResp
** 15 - RpbListBucketsReq
** 16 - RpbListBucketsResp{1,}
** 17 - RpbListKeysReq
** 18 - RpbListKeysResp{1,}
** 19 - RpbMapRedReq
** 20 - RpbMapRedResp{1,}
**
** Protocol 
**  
**   On connect, server sends RpbHello with protocol/node information.
**   After that client can make requests and will receive responses
** 
**   RpbPingReq -> RpbPingResp
**   RpbGetReq -> RpbErrorResp | RbpGetResp
**   RpbPutReq -> RpbErrorResp | RpbPutResp
**   RpbDelReq -> RpbErrorResp | RpbDelResp
**   RpbGetBucketPropsReq -> RpbErrorResp | RpbGetBucketPropsResp
**   RpbSetBucketPropsReq -> RpbErrorResp | RpbSetBucketPropsResp
**   RpbListBucketsReq -> RpbErrorResp | RpbListBucketsResp{1,}
**   RpbListKeysReq -> RpbErrorResp | RpbListKeysResp{1,}
**   RpbMapRedReq -> RpbErrorResp | RpbMapRedResp{1,}
*/

message RpbErrorResp {
    required bytes errmsg = 1;
}

// Hello request - a client must say hello to the server on connection
// with the maximum protocol version supported.
message RpbHelloReq {
    required int32 proto_major = 1; // Set to 1 for now
    optional bytes client_id = 2;   // Client id to use
}

// Hello response from the server
message RpbHelloResp {
    optional int32 proto_major = 1;
    optional int32 proto_minor = 2;
    optional bytes node = 3;
    optional bytes client_id = 4; 
    optional bytes server_version = 5;
}

// Get Request - retrieve bucket/key
message RpbGetReq {
    required bytes bucket = 1;
    required bytes key = 2;
    optional RpbOptions options = 3;
}

// Get Response - if the record was not found there will be no content/vclock
message RpbGetResp {
    repeated RpbContent content = 1;
    optional bytes vclock = 2;
}

message RpbPutReq {
    required bytes bucket = 1;
    required bytes key = 2;
    optional bytes vclock = 3;
    required RpbContent content = 4;
    optional RpbOptions options = 5;
}

message RpbPutResp {
    repeated RpbContent contents = 1;
    optional bytes vclock = 2;
}

message RpbDelReq {
    required bytes bucket = 1;
    required bytes key = 2;
    optional RpbOptions options = 3;
}

message RpbGetBucketPropsReq {
    required bytes bucket = 1;
    repeated bytes names = 2; // list of property names to receive - if empty return all
}

message RpbGetBucketPropsResp {
    required RpbTerm properties = 1;
}

message RpbSetBucketPropsReq {
    required bytes bucket = 1;
    required RpbTerm properties = 2; 
    optional RpbOptions options = 3;
}

message RpbListBucketsReq {
}

message RpbListBucketsResp {
    repeated bytes buckets = 1;
    optional bool done = 2;
}

message RpbListKeysReq {
    required bytes bucket = 1;
    optional RpbOptions options = 2;
}

message RpbListKeysResp {
    repeated bytes keys = 1;
    optional bool done = 2;
}

message RpbMapRedReq {
    optional bytes input_bucket = 1; // Input bucket
    repeated RpbMapRedInput input_keys = 2; // *OR* input_keys - not both
    repeated RpbMapRedPhase phases = 3; // query is reserved word in erlang
}
message RpbMapRedResp {
    optional int32 phase = 1;
    optional RpbTerm data = 2;
    optional bool done = 3;
}

message RpbContent {
    required bytes value = 1;
    optional RpbTerm metadata = 2;
    optional bytes content_type = 3;
    optional bytes charset = 4;
    optional bytes content_encoding = 5;
    optional bytes vtag = 6;
    repeated RpbLink links = 7;
    optional int32 last_mod = 8;
    optional int32 last_mod_usecs = 9;
    repeated RpbPair usermeta = 10;
}

message RpbPair {
    required bytes key = 1;
    optional bytes value = 2;
}

message RpbLink {
    optional bytes bucket = 1;
    optional bytes key = 2;
    optional bytes tag = 3;
}

message RpbOptions {
    optional int32 r = 1;
    optional int32 w = 2;
    optional int32 dw = 3;
    optional int32 rw = 4;
    optional bool return_body = 5;
}

/* Type values - no enums
** 1 = integer
** 2 = boolean (uses int_val. 0 == false, !0 == true)
** 3 = string
** 5 = object - JSON-like name/value pairs
** 6 = array 
*/
message RpbTerm {
    required int32 type = 1;
    optional int32 int_value = 3;
    optional bytes string_value = 4;
    repeated RpbObjectEntry object_entries = 5;
    repeated RpbTerm array_values = 6;
}
message RpbObjectEntry {
    required bytes name = 1;
    required RpbTerm value = 2;
}

message RpbMapRedInput {
    required bytes bucket = 1;
    required bytes key = 2;     
    optional RpbTerm data = 3; //* What format should this be in? - maybe RpbTerm?
}

message RpbMapRedPhase {
    required bytes type = 1;
    optional bytes language = 2;
    optional bytes source = 3;
    optional bytes bucket = 4;
    optional bytes key = 5;
    optional bytes module = 6;
    optional bytes function = 7;
    optional bool keep = 8;
    optional bytes tag = 9;
    optional RpbTerm arg = 10;
}