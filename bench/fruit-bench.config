%% This config will run the synthetic "fruit bench" against Riak
%% Search.  It is designed to test the conjunction query ('AND')
%% support.

{mode, max}.
{duration, 5}.
{concurrent, 4}.
{driver, rs_bb_driver}.
{code_paths, ["/Users/rzezeski/work/riak_search"]}.
{rs_index_path, "/riak/fruit"}.
{rs_search_path, "/solr/fruit/select"}.
{rs_ports, [{"127.0.0.1", 8091}, {"127.0.0.1", 8092},
            {"127.0.0.1", 8093}, {"127.0.0.1", 8094}]}.
{pb_ports, []}.

%% The following keygen/ops will load the data, run this first and
%% then execute the query benchmarks
%% {key_generator, {function,  rs_bb_driver, fruit_key_val_gen, []}}.
%% {operations, [{load_fruit, 1}]}.

%% The following are the various fruit queries to run.

%% Alpha
%%
%% This query is one of the best cases for the smarter conjunction b/c
%% one of the queries matches 0 terms and two others match 100K docs.
%% This means the old conjunction will do all the work of iterating
%% 200K docs where the smart one will do 0.
%%
%% cardinalities: 100K, 100K, 0
{operations, [{{exact_search, "pineapple AND grape AND notafruit"}, 1}]}.

%% Beta
%%
%% Another best case for smart conj, but unlike last one there is a
%% total of 1 doc that matches so it must be streamed thru the other 2
%% 100K matches.
%% {operations, [{{exact_search, "apple AND orange AND jujube"}, 1}]}.

%% Charlie
%%
%% This is another great case for smart conj b/c all but one term
%% matches 100K docs.
%%
%% cardinalities: 100K, 100K, 1, 100K, 100K, 100K
%% {operations, [{{exact_search, "apple AND grape AND elderberry AND orange AND pineapple AND strawberry"}, 1}]}.

%% Delta
%%
%% This is a good case for smart conj b/c it has some largeish matches
%% but one matches only 10
%%
%% cardinalities: 10K, 100, 10
%% {operations, [{{exact_search, "avocado AND nutmeg AND nance"}, 1}]}.

%% Echo
%%
%% Another good case, this one starts to potentially even out between
%% old/new conj since all terms match small number of postings.
%%
%% cardinalities: 10, 1K, 10
%% {operations, [{{exact_search, "mulberry AND clementine AND peanut"}, 1}]}.

%% Foxtrot
%%
%% This is potentially a bad case for smart conj since all terms match
%% same number of docs and smart conj is sequential rather than parallel.
%%
%% cardinalities: 10K, 10K, 10K
%% {operations, [{{exact_search, "persimmon AND cherry AND tomato"}, 1}]}.

%% Golf
%%
%% This is kind of a mix between bad/good for smart conj.  1k doc ids
%% will have to be copied over.
%%
%% cardinalities: 1K, 10K, 100K
%% {operations, [{{exact_search, "lime AND raspberry AND grape"}, 1}]}.

%% Hotel
%%
%% I imagine this is worst case for smart conj.  All terms match 100K
%% docs.
%%
%% cardinalities: 100K, 100K, 100K
%% {operations, [{{exact_search, "strawberry AND kiwi AND orange"}, 1}]}.

%% India
%%
%% This case is meant to check for overhead in smart conj and just
%% test out querying many terms.
%%
%% cardinalities: 1, 10, 1, 100, 10
%% {operations, [{{exact_search, "korlan AND nunga AND genip AND nutmeg AND kumquat"}, 1}]}.

%% Juliet
%%
%% This case is meant to check for _any_ overhead imposed by smart
%% conj.  The thinking is that if all terms match a small number of
%% docs then parallel will be better than sequential.  If smart conj
%% can break even here and on the worst case then that is really good.
%%
%% cardinalities: 1, 1
%% {operations, [{{exact_search, "citron AND jocote"}, 1}]}.
